void SpecificWorker::compute()
{
	// -----------------------
	// 1 Leer datos del LIDAR
	// -----------------------
	std::optional<RoboCompLidar3D::TPoints> filter_data;
	try
	{
		// Obtener datos 3D del LIDAR con umbral
		auto data = lidar3d_proxy->getLidarDataWithThreshold2d("helios", 5000, 1);

		// Mostrar información de depuración
		qInfo() << "Full" << data.points.size();

		if (data.points.empty())
		{
			qWarning() << "No points received";
			return;
		}

		// -----------------------
		// 2 Filtrar datos 3D → 2D
		// -----------------------
		filter_data = filter_min_distance_cppitertools(data.points);

		qInfo() << "Filtered points:" << filter_data.value().size();

		// -----------------------
		// 3 Dibujar los puntos filtrados en Qt
		// -----------------------
		if (filter_data.has_value())
			draw_lidar(filter_data.value(), &viewer->scene);
	}
	catch(const Ice::Exception &e)
	{
		std::cout << "Error reading from Lidar: " << e << std::endl;
		return;
	}

	// -----------------------
	// 4 Decidir velocidades usando chocachoca
	// -----------------------
	float advance_speed = 0, rotation_speed = 0;
	if (filter_data.has_value())
		chocachoca(filter_data, advance_speed, rotation_speed);

	// -----------------------
	// 5 Enviar velocidades al robot
	// -----------------------
	try
	{
		omnirobot_proxy->setSpeedBase(0, advance_speed, rotation_speed);
	}
	catch (const Ice::Exception &e)
	{
		std::cout << "Error sending speed to robot: " << e.what() << std::endl;
		return;
	}

	// -----------------------
	// 6 Actualizar posición del robot en la GUI (opcional)
	// -----------------------
	update_ropot_position();
}
