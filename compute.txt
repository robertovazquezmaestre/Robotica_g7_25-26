void SpecificWorker::compute()
{

	try
	{
		auto data = laser_proxy->getLaserData();
	}
	catch(const Ice::Exception &e) {std::cout << e << "Conexion con laser" << std::endl;}

	std::vector<QPointF> cloud_2d;
	for (const auto &p : data)
	{
			float x = p.dist * std::cos(p.angle);
			float y = p.dist * std::sin(p.angle);
			cloud_2d.emplace_back(x, y);
	}
	// Aqui se hace la llamda al QTWindow
	
	auto it = std::min_element(cloud_2d.begin(), cloud_2d.end(),
        [](const QPointF &a, const QPointF &b)
        {
            float da = std::sqrt(a.x()*a.x() + a.y()*a.y());
            float db = std::sqrt(b.x()*b.x() + b.y()*b.y());
            return da < db;
        });
	float min_dist = std::sqrt(it->x()*it->x() + it->y()*it->y());
	const float SAFE_DISTANCE = 600.0f;  // mm

	if (min_dist < SAFE_DISTANCE)
	{
		omnirobot_proxy->setSpeedBase(0.0, 0.5);  // girar
	}
	else
	{
		omnirobot_proxy->setSpeedBase(200.0,0.0); // avanzar
	}
